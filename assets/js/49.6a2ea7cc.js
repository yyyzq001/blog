(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{478:function(n,t,s){"use strict";s.r(t);var e=s(2),i=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"一、js实现类似百度地图的缩放拖动功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、js实现类似百度地图的缩放拖动功能"}},[n._v("#")]),n._v(" 一、js实现类似百度地图的缩放拖动功能")]),n._v(" "),t("h2",{attrs:{id:"使用的前端框架为vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用的前端框架为vue"}},[n._v("#")]),n._v(" 使用的前端框架为vue")]),n._v(" "),t("p",[n._v("采用vue的框架,通过canvas的缩放绘制和外层div的滚动条控制实现功能")]),n._v(" "),t("h2",{attrs:{id:"滚轮事件代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滚轮事件代码"}},[n._v("#")]),n._v(" 滚轮事件代码")]),n._v(" "),t("div",{staticClass:"language-//滚轮放大 extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n    handleScroll(e) {\n\n      console.log(e.deltaY)\n\n      let _this = this\n\n      if (e.deltaY > 0 && _this.zoomtimes > 1) {\n\n        _this.zoomtimes = (_this.zoomtimes * 10 - 2) / 10\n\n      } else if (e.deltaY < 0) {\n\n        _this.zoomtimes = (_this.zoomtimes * 10 + 2) / 10\n\n      }\n\n      this.down_x = e.clientX\n\n      this.down_y = e.clientY\n\n      if (e.deltaY > 0) {\n\n        _this.direction = 1\n\n      } else {\n\n        _this.direction = 0\n\n      }\n\n      e.preventDefault()\n\n    },\n\nwheelxy() {\n\n      let _this = this\n\n      if (_this.direction == 0) {\n\n        _this.$store.state.scroll_x = _this.$refs.imageWrapper.scrollLeft =\n\n          (((_this.$refs.imageWrapper.clientWidth - 10) * _this.zoomtimes) /\n\n            ((_this.$refs.imageWrapper.clientWidth - 10) *\n\n              (_this.zoomtimes - 0.2)) -\n\n            1) *\n\n            (_this.down_x - 67 + _this.$refs.imageWrapper.scrollLeft) +\n\n          _this.$refs.imageWrapper.scrollLeft\n\n        _this.$store.state.scroll_y = _this.$refs.imageWrapper.scrollTop =\n\n          (((_this.$refs.imageWrapper.clientHeight - 10) * _this.zoomtimes) /\n\n            ((_this.$refs.imageWrapper.clientHeight - 10) *\n\n              (_this.zoomtimes - 0.2)) -\n\n            1) *\n\n            (_this.down_y - 193 + _this.$refs.imageWrapper.scrollTop) +\n\n          _this.$refs.imageWrapper.scrollTop\n\n      } else {\n\n        _this.$store.state.scroll_x = _this.$refs.imageWrapper.scrollLeft =\n\n          (1 -\n\n            ((_this.$refs.imageWrapper.clientWidth - 10) *\n\n              (_this.zoomtimes + 0.2)) /\n\n              ((_this.$refs.imageWrapper.clientWidth - 10) * _this.zoomtimes)) *\n\n            (_this.down_x - 67 + _this.$refs.imageWrapper.scrollLeft) +\n\n          _this.$refs.imageWrapper.scrollLeft\n\n        _this.$store.state.scroll_y = _this.$refs.imageWrapper.scrollTop =\n\n          (1 -\n\n            ((_this.$refs.imageWrapper.clientHeight - 10) *\n\n              (_this.zoomtimes + 0.2)) /\n\n              ((_this.$refs.imageWrapper.clientHeight - 10) *\n\n                _this.zoomtimes)) *\n\n            (_this.down_y - 193 + _this.$refs.imageWrapper.scrollTop) +\n\n          _this.$refs.imageWrapper.scrollTop\n\n      }\n\n    },\n\n")])])]),t("p",[n._v("通过监听zoomtimes字段获取缩放倍数,调用canvas绘制,canvas绘制完成后调用wheelxy()函数实现定位滑动条位置为鼠标指针中心.")]),n._v(" "),t("h2",{attrs:{id:"拖动事件代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拖动事件代码"}},[n._v("#")]),n._v(" 拖动事件代码")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nmouse_down(e) {\n\n      console.log(this.$store.state.scroll_x)\n\n      this.down_x = e.clientX\n\n      this.down_y = e.clientY\n\n      this.$refs.imageWrapper.scrollLeft = this.$store.state.scroll_x\n\n      this.$refs.imageWrapper.scrollTop = this.$store.state.scroll_y\n\n      this.mouseevent = true\n\n    },\n\n    mouse_move(e) {\n\n      if (this.mouseevent) {\n\n        let x = e.clientX - this.down_x\n\n        let y = e.clientY - this.down_y\n\n        this.$refs.imageWrapper.scrollLeft = this.$store.state.scroll_x - x\n\n        this.$refs.imageWrapper.scrollTop = this.$store.state.scroll_y - y\n\n      }\n\n    },\n\n    mouse_up(e) {\n\n      this.$store.state.scroll_x = this.$refs.imageWrapper.scrollLeft\n\n      this.$store.state.scroll_y = this.$refs.imageWrapper.scrollTop\n\n      this.mouseevent = false\n\n    },\n\n")])])]),t("p",[n._v("拖动时注册三个事件函数,用vuex记录每次放开鼠标或缩放完成后的滚动条位置")]),n._v(" "),t("h2",{attrs:{id:"实现方法逻辑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现方法逻辑"}},[n._v("#")]),n._v(" 实现方法逻辑")]),n._v(" "),t("p",[n._v("通过计算canvas缩放时的倍数计算出x轴和y轴的增量△x和△y,其中判断鼠标滚轮方向以使用不同的计算公式,放大时△x = ( canvas.width' / canvas.width  - 1)  x,  缩小时 △x = ( 1 - canvas.width / canvas.width' )  x',△y同理,而x,y轴的偏移量就是滚动条应该滚动的大小,每次叠加到上一次的数据中.")]),n._v(" "),t("p",[n._v("拖动时,以每次vuex记录的的滚动条位置为起点进行拖动")]),n._v(" "),t("h2",{attrs:{id:"后续更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后续更新"}},[n._v("#")]),n._v(" 后续更新")]),n._v(" "),t("p",[n._v("通过实际测试发现,通过增量△x与△y操作的缩放拖动功能虽然能实现需求功能,但是在实际运用时发现会产生不流畅的迟钝感.")]),n._v(" "),t("p",[n._v("个人原本认为是因为每次移动或缩放产生的大量计算导致浏览器的canvas性能出现问题,但经过查询资料和实际测试发现,这种程度的计算远远没有达到浏览器的性能瓶颈,所以说明产生钝感的原因的核心还是算法的问题,因为算法的不细致导致了动画效果的不流畅.")]),n._v(" "),t("p",[n._v("在几次查询资料之后,我修改了代码的算法逻辑,新的算法和之前相比更加的丝滑,代码如下:")]),n._v(" "),t("h2",{attrs:{id:"新滚轮事件代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新滚轮事件代码"}},[n._v("#")]),n._v(" 新滚轮事件代码")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nhandleScroll(e) {\n\n      let _this = this\n\n      _this.down_xy = _this.windowToCanvas(e.clientX, e.clientY)\n\n      let newDown_xy = {\n\n        x: (\n\n          (_this.down_xy.x - _this.imgX - _this.b) /\n\n          _this.zoomtimes /\n\n          _this.ts\n\n        ).toFixed(2),\n\n        y: (\n\n          (_this.down_xy.y - _this.imgY - _this.a) /\n\n          _this.zoomtimes /\n\n          _this.ts\n\n        ).toFixed(2)\n\n      }\n\n      if (e.deltaY > 0 && _this.zoomtimes > 1 && _this.zoomtimes < 1.1) {\n\n        _this.zoomtimes = 1\n\n        _this.imgX =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.x +\n\n          (_this.down_xy.x - newDown_xy.x) -\n\n          _this.b\n\n        _this.imgY =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.y +\n\n          (_this.down_xy.y - newDown_xy.y) -\n\n          _this.a\n\n      } else if (e.deltaY > 0 && _this.zoomtimes > 1) {\n\n        _this.zoomtimes = (_this.zoomtimes * 10 - 1) / 10\n\n        _this.imgX =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.x +\n\n          (_this.down_xy.x - newDown_xy.x) -\n\n          _this.b\n\n        _this.imgY =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.y +\n\n          (_this.down_xy.y - newDown_xy.y) -\n\n          _this.a\n\n      } else if (e.deltaY < 0) {\n\n        _this.zoomtimes = (_this.zoomtimes * 10 + 1) / 10\n\n        _this.imgX =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.x +\n\n          (_this.down_xy.x - newDown_xy.x) -\n\n          _this.b\n\n        // (1 - _this.zoomtimes) * _this.down_xy.x - _this.b\n\n        _this.imgY =\n\n          (1 - _this.zoomtimes * _this.ts) * newDown_xy.y +\n\n          (_this.down_xy.y - newDown_xy.y) -\n\n          _this.a\n\n        // (1 - _this.zoomtimes ) * _this.down_xy.y - _this.a\n\n      }\n\n      this.$store.state.move_item = ''\n\n      e.preventDefault()\n\n      console.info(_this.imgX, _this.imgY, 'sdsdsdsdsd')\n\n    },\n\n    windowToCanvas(x, y) {\n\n      let mycanvas = document.getElementById('canvas_img')\n\n      let box = mycanvas.getBoundingClientRect() //这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离\n\n      return {\n\n        x: x - box.left - (box.width - mycanvas.width) / 2,\n\n        y: y - box.top - (box.height - mycanvas.height) / 2\n\n      }\n\n    },\n\n")])])]),t("h2",{attrs:{id:"新拖动事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新拖动事件"}},[n._v("#")]),n._v(" 新拖动事件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nmouse_down(e) {\n\n      console.log(this.$store.state.scroll_x)\n\n      this.mouseevent = true\n\n      this.down_xy = this.windowToCanvas(e.clientX, e.clientY)\n\n    },\n\n    mouse_move(e) {\n\n      if (this.mouseevent) {\n\n        this.down_xyl = this.windowToCanvas(e.clientX, e.clientY)\n\n        let x = this.down_xyl.x - this.down_xy.x,\n\n          y = this.down_xyl.y - this.down_xy.y\n\n        this.imgX += x\n\n        this.imgY += y\n\n        this.down_xy = JSON.parse(JSON.stringify(this.down_xyl))\n\n      }\n\n    },\n\n    mouse_up(e) {\n\n      if (this.mouseevent) {\n\n        this.$store.state.move_item = ''\n\n      }\n\n      this.mouseevent = false\n\n    },\n\n")])])]),t("p",[n._v("其中 _this.a, _this.b, _this.ts都是这个项目中canvas的效果需求特殊定义的,比如ts变量指原图放到canvas时的比例,a,b为图片初始位置对canvas边框的距离,如果要测试的话可以先去掉不用,根据自己的情况添加")])])}),[],!1,null,null,null);t.default=i.exports}}]);