(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{473:function(e,a,n){"use strict";n.r(a);var t=n(2),l=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"五、vue-文件上传后的diy操作及二进制流blob文件的下载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、vue-文件上传后的diy操作及二进制流blob文件的下载"}},[e._v("#")]),e._v(" 五、Vue  文件上传后的diy操作及二进制流blob文件的下载")]),e._v(" "),a("h2",{attrs:{id:"文件上传部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件上传部分"}},[e._v("#")]),e._v(" 文件上传部分")]),e._v(" "),a("p",[e._v("1.文件的上传\n常规的文件上传是通过form表单包裹file类型的input标签进行上传,在form里面的属性中定义上传方式如post,上传地址url,或者通过如elementUI的upload模块进行一系列的上传操作.但很多时候我们并不需要用到那么多复杂功能,所以文件上传的本质应该只有两步:\n(1)将本地文件上传到浏览器端\n(2)将浏览器端的文件发送到对应api接口\n其他的额外操作可以由自己定义.\n2.具体代码\n上传代码如下:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<el-button @click="upload" type="primary">上传图片</el-button>\n              <input\n                @change="getimg"\n                accept="image/x-png, image/gif, image/jpeg, image/bmp"\n                class="fileupload"\n                ref="fileupload"\n                type="file"\n              />\nupload() {\n      this.$refs.fileupload.dispatchEvent(new MouseEvent(\'click\'))\n    },\n')])])]),a("p",[e._v("file类型的input样式很丑而且很不好修改,一般的话对于其的样式优化是将input标签设置为display:none,用我们自定义的按钮或其他来绑定input的点击事件以完成上传的diy风格.")]),e._v(" "),a("p",[e._v("然后是获取上传文件在浏览器的地址:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" getimg() {\n      let file = this.$refs.fileupload.files[0]\n      this.filename = file.name\n      let reader = new FileReader() //读取文件\n      reader.readAsDataURL(file)\n      let _this = this\n      reader.onload = function() {\n        _this.$refs.imgshow.src = reader.result\n      }\n    }\n")])])]),a("p",[e._v("一般只有图片需要用到该功能来预览")]),e._v(" "),a("p",[e._v("发送api部分:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("addWatermark() {\n      this.fullscreenLoading = true\n      let file = this.$refs.fileupload.files[0]\n      let param = new FormData()\n      // 将得到的文件流添加到FormData对象\n      param.append('file', file, file.name)\n      this.$api.search.addWatermark(param).then()\n}\n")])])]),a("p",[e._v("文件上传之后本身并不能直接和一般的数据格式发过去,所以要放在formdata类里面才能达到和包裹在form里面传输一样的效果\n注:传输文件是request里面的Content-Type属性一定要是: multipart/form-data")]),e._v(" "),a("p",[e._v("#blob下载\n很多时候我们从后端接口api拿到的文件类型往往是二进制流的文件,对于这个文件我们前端无法直接下载,所以要通过几步操作\n1.请求接口是要告诉接口我请求的是blob类型:responseType: 'blob'\n如axios是这样的axios.post("),a("code",[e._v("/addWaterMark")]),e._v(", params, { responseType: 'blob' });\n2.收到请求回调时要对文件blob解析后下载\n具体代码是:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (res.status == 200) {\n          let blob = new Blob([res.data])\n          //将二进制流blob数据转化为js认识的blob对象\n          //有时还要加上类型判别如: let blob = new Blob([res.data], {\n          // type: 'application/vnd.ms-excel'\n          //})\n          let downloadA = document.createElement('a')\n          downloadA.download = 'WM_' + this.filename\n          //下载文件命名\n          downloadA.href = window.URL.createObjectURL(blob)\n          //获取下载路径\n          downloadA.click()\n}\n")])])]),a("p",[e._v("blob类型汇总\n后缀\t         MIME Type\n.doc\t         application/msword\n.docx\t application/vnd.openxmlformats-officedocument.wordprocessingml.document\n.xls\t         application/vnd.ms-excel\n.xlsx\t         application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n.ppt\t         application/vnd.ms-powerpoint\n.pptx\t application/vnd.openxmlformats-officedocument.presentationml.presentation")])])}),[],!1,null,null,null);a.default=l.exports}}]);